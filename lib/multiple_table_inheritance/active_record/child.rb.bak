module MultipleTableInheritance
  module ActiveRecord
    module Child
      def self.default_options
        { :dependent => :destroy, :inherit_methods => false }
      end
      
      def self.included(base)
        base.extend(ClassMethods)
      end
      
      module ClassMethods
        def inherits_from(association_name, options={})
          # Standardize parameters.
          association_name = association_name.to_sym
          options = Child::default_options.merge(options.to_options.reject { |k,v| v.nil? })
          
          # Remove options that should not affect the belongs_to relationship.
          inherit_methods = options.delete(:inherit_methods)
          
          # Add an association, and set the foreign key.
          belongs_to association_name, options
          
          # Set the primary key since the inheriting table includes no `id` column.
          self.primary_key = "#{association_name}_id"
          
          # Always return an instance of the parent class, whether it be an existing or new instance.
          always_return_association(association_name)
          
          # Ensure the parent specifies the current class as the subtype.
          associate_before_validation(association_name)
          
          # Bind the validation of association.
          validate_association(association_name)
          
          # Ensure both the parent and the child records are saved.
          save_association(association_name)
          
          # Create proxy methods for instances of this class.
          create_instance_methods(association_name)
          
          # Delegate all missing method calls to the parent association if preferred.
          delegate_parent_methods(association_name) if inherit_methods
        end
        
        private
        
        def always_return_association(association_name)
          define_method("#{association_name}_with_autobuild") do
            send("#{association_name}_without_autobuild") || send("build_#{association_name}")
          end
          
          alias_method_chain association_name, :autobuild    
        end
        
        def associate_before_validation(association_name)
          define_method(:set_subtype) do
            association = send(association_name)
            if association.attribute_names.include?(association.class.subtype_column)
              association[association.class.subtype_column] = self.class.to_s
            end
          end
          
          before_validation :set_subtype
        end
        
        def validate_association(association_name)
          define_method(:parent_association_must_be_valid) do
            association = send(association_name)
            
            unless valid = association.valid?
              association.errors.each do |attr, message|
                errors.add(attr, message)
              end
            end
            
            valid
          end
          
          validate :parent_association_must_be_valid
        end
        
        def save_association(association_name)
          define_method(:parent_association_must_be_saved) do
            association = send(association_name)
            association.save(:validate => false)
            self.id = association.id
          end
          
          before_save :parent_association_must_be_saved
        end
        
        def create_instance_methods(association_name)
          inherited_columns_and_methods(association_name).each do |name|
            delegate name, "#{name}=", :to => association_name
          end
        end
        
        def inherited_columns_and_methods(association_name)
          # Get the class of association by reflection
          reflection = create_reflection(:belongs_to, association_name, {}, self)
          association_class = reflection.class_name.constantize
          inherited_columns = association_class.column_names
          inherited_methods = association_class.reflections.map { |key, value| key.to_s }
          
          # Filter out columns that the class already has
          inherited_columns = inherited_columns.reject do |column|
            (self.column_names.grep(column).length > 0) || (column == 'type') || (column == association_class.subtype_column)
          end
          
          # Filter out columns that the class already has
          inherited_methods = inherited_methods.reject do |method|
            self.reflections.map { |key, value| key.to_s }.include?(method)
          end
          
          inherited_columns + inherited_methods - ['id']
        end
        
        def delegate_parent_methods(association_name)
          define_method("method_missing") do |name, *args|
            association = self.public_send(association_name)
            if association.present? && association.respond_to?(name)
              association.send(name, *args)
            else
              super(name, *args)
            end
          end
        end
      end
    end
  end
end
